#include "minispdlog/minispdlog.h"
#include "minispdlog/async.h"
#include <iostream>
#include <chrono>
#include <thread>
#include <vector>
#include <sys/stat.h>
#include <sys/types.h>

using namespace std::chrono;

// 创建目录
bool create_directory(const std::string& path) {
#ifdef _WIN32
    return _mkdir(path.c_str()) == 0 || errno == EEXIST;
#else
    return mkdir(path.c_str(), 0755) == 0 || errno == EEXIST;
#endif
}

// 性能计时器 - 更精确的版本
class Timer {
public:
    Timer() : start_(high_resolution_clock::now()) {}
    
    void reset() {
        start_ = high_resolution_clock::now();
    }
    
    double elapsed_ms() const {
        auto end = high_resolution_clock::now();
        return duration_cast<microseconds>(end - start_).count() / 1000.0;
    }
    
private:
    high_resolution_clock::time_point start_;
};

// 单线程性能测试 - 改进版
void benchmark_single_thread(const std::string& name, 
                             std::shared_ptr<minispdlog::logger> logger,
                             int iterations,
                             bool is_async) {
    Timer timer;
    
    // 只计时日志调用本身
    for (int i = 0; i < iterations; ++i) {
        logger->info("Benchmark message #{} - some additional text", i);
    }
    
    double log_time = timer.elapsed_ms();
    
    // flush 的时间单独计时(不计入吞吐量)
    timer.reset();
    logger->flush();
    
    if (is_async) {
        // 异步需要等待后台处理完成
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
    }
    
    double flush_time = timer.elapsed_ms();
    double total_time = log_time + flush_time;
    
    // 使用日志调用时间计算吞吐量(更能反映用户体验)
    double throughput_on_log_time = iterations / (log_time / 1000.0);
    double throughput_on_total_time = iterations / (total_time / 1000.0);
    
    std::cout << name << ":\n"
              << "  消息数: " << iterations << "\n"
              << "  日志调用耗时: " << log_time << " ms\n"
              << "  flush等待耗时: " << flush_time << " ms\n"
              << "  总耗时: " << total_time << " ms\n"
              << "  调用吞吐量: " << static_cast<int>(throughput_on_log_time) << " msg/sec "
              << "(用户线程视角)\n"
              << "  实际吞吐量: " << static_cast<int>(throughput_on_total_time) << " msg/sec "
              << "(包含后台处理)\n"
              << std::endl;
}

// 多线程性能测试 - 改进版
void benchmark_multi_thread(const std::string& name,
                           std::shared_ptr<minispdlog::logger> logger,
                           int thread_count,
                           int messages_per_thread,
                           bool is_async) {
    Timer timer;
    
    // 只计时日志调用本身
    std::vector<std::thread> threads;
    for (int t = 0; t < thread_count; ++t) {
        threads.emplace_back([logger, messages_per_thread, t]() {
            for (int i = 0; i < messages_per_thread; ++i) {
                logger->info("Thread {} - Message #{}", t, i);
            }
        });
    }
    
    for (auto& thread : threads) {
        thread.join();
    }
    
    double log_time = timer.elapsed_ms();
    
    // flush 的时间单独计时
    timer.reset();
    logger->flush();
    
    if (is_async) {
        std::this_thread::sleep_for(std::chrono::milliseconds(300));
    }
    
    double flush_time = timer.elapsed_ms();
    double total_time = log_time + flush_time;
    
    int total_messages = thread_count * messages_per_thread;
    double throughput_on_log_time = total_messages / (log_time / 1000.0);
    double throughput_on_total_time = total_messages / (total_time / 1000.0);
    
    std::cout << name << ":\n"
              << "  线程数: " << thread_count << "\n"
              << "  每线程消息数: " << messages_per_thread << "\n"
              << "  总消息数: " << total_messages << "\n"
              << "  日志调用耗时: " << log_time << " ms\n"
              << "  flush等待耗时: " << flush_time << " ms\n"
              << "  总耗时: " << total_time << " ms\n"
              << "  调用吞吐量: " << static_cast<int>(throughput_on_log_time) << " msg/sec "
              << "(用户线程视角)\n"
              << "  实际吞吐量: " << static_cast<int>(throughput_on_total_time) << " msg/sec "
              << "(包含后台处理)\n"
              << std::endl;
}

int main() {
    std::cout << "========================================" << std::endl;
    std::cout << "  MiniSpdlog 性能测试 (改进版)" << std::endl;
    std::cout << "========================================\n" << std::endl;
    
    create_directory("logs");
    
    // 增加消息数量以更好地体现差异
    constexpr int single_iterations = 500000;  // 50万条
    constexpr int multi_threads = 8;           // 8线程
    constexpr int multi_messages = 62500;      // 每线程6.25万 = 总50万
    
    try {
        // ========== 单线程性能对比 ==========
        std::cout << "【单线程性能测试 - " << single_iterations << " 条消息】\n" << std::endl;
        
        // 同步文件日志
        {
            std::cout << "测试同步文件日志..." << std::endl;
            minispdlog::drop("sync_file_bench");
            
            auto sync_logger = minispdlog::basic_logger_st(
                "sync_file_bench",
                "logs/bench_sync.log",
                true
            );
            benchmark_single_thread("同步文件日志", sync_logger, single_iterations, false);
            minispdlog::drop("sync_file_bench");
        }
       
        // ========== 多线程性能对比 ==========
        std::cout << "\n【多线程性能测试 - " << multi_threads << " 线程 x " 
                  << multi_messages << " 消息】\n" << std::endl;
        
        // 同步文件日志
        {
            std::cout << "测试同步文件日志(多线程)..." << std::endl;
            minispdlog::drop("sync_multi_bench");
            
            auto sync_logger = minispdlog::basic_logger_mt(
                "sync_multi_bench",
                "logs/bench_sync_multi.log",
                true
            );
            benchmark_multi_thread("同步文件日志", sync_logger, multi_threads, multi_messages, false);
            minispdlog::drop("sync_multi_bench");
        }
        
        // 异步文件日志(1个工作线程)
        {
            std::cout << "测试异步文件日志(1工作线程)..." << std::endl;
            minispdlog::drop("async_multi_bench");
            
            minispdlog::init_thread_pool(32768, 1);  // 更大的队列
            auto async_logger = minispdlog::async_file_mt(
                "async_multi_bench",
                "logs/bench_async_multi.log",
                true,
                minispdlog::async_overflow_policy::block
            );
            benchmark_multi_thread("异步文件日志(1工作线程)", async_logger, multi_threads, multi_messages, true);
            minispdlog::drop("async_multi_bench");
        }
        
        // 异步文件日志(overrun策略,展示最佳性能)
        {
            std::cout << "测试异步文件日志(overrun策略)..." << std::endl;
            minispdlog::drop("async_multi_overrun");
            
            minispdlog::init_thread_pool(32768, 1);
            auto async_logger = minispdlog::async_file_mt(
                "async_multi_overrun",
                "logs/bench_async_multi_overrun.log",
                true,
                minispdlog::async_overflow_policy::overrun_oldest
            );
            benchmark_multi_thread("异步文件日志(overrun)", async_logger, multi_threads, multi_messages, true);
            minispdlog::drop("async_multi_overrun");
        }
        
        // ========== 性能总结 ==========
        std::cout << "\n========================================" << std::endl;
        std::cout << "  性能测试总结" << std::endl;
        std::cout << "========================================" << std::endl;
        std::cout << "\n关键观察:\n"
                  << "1. 异步日志的'调用吞吐量'代表用户线程的体验(非阻塞)\n"
                  << "2. 异步日志在多线程场景下优势更明显\n"
                  << "3. overrun策略适合能容忍消息丢失但要求极致性能的场景\n"
                  << "4. 消息量越大,异步优势越明显\n"
                  << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "测试失败: " << e.what() << std::endl;
        return 1;
    }
    
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    return 0;
}

#if 0
#include "minispdlog/minispdlog.h"
#include "minispdlog/async.h"
#include <iostream>
#include <chrono>
#include <thread>
#include <vector>
#include <sys/stat.h>
#include <sys/types.h>

using namespace std::chrono;

// 创建目录的跨平台函数
bool create_directory(const std::string& path) {
#ifdef _WIN32
    return _mkdir(path.c_str()) == 0 || errno == EEXIST;
#else
    return mkdir(path.c_str(), 0755) == 0 || errno == EEXIST;
#endif
}

// 性能计时器
class Timer {
public:
    Timer() : start_(high_resolution_clock::now()) {}
    
    double elapsed_ms() const {
        auto end = high_resolution_clock::now();
        return duration_cast<microseconds>(end - start_).count() / 1000.0;
    }
    
private:
    high_resolution_clock::time_point start_;
};

// 单线程性能测试
void benchmark_single_thread(const std::string& name, 
                             std::shared_ptr<minispdlog::logger> logger,
                             int iterations) {
    Timer timer;
    
    for (int i = 0; i < iterations; ++i) {
        logger->info("Benchmark message #{} - some additional text", i);
    }
    
    // 刷新并等待完成
    logger->flush();
    
    // 给异步 logger 更多时间完成
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    double elapsed = timer.elapsed_ms();
    double throughput = iterations / (elapsed / 1000.0);
    
    std::cout << name << ":\n"
              << "  消息数: " << iterations << "\n"
              << "  耗时: " << elapsed << " ms\n"
              << "  吞吐量: " << static_cast<int>(throughput) << " msg/sec\n"
              << std::endl;
}

// 多线程性能测试
void benchmark_multi_thread(const std::string& name,
                           std::shared_ptr<minispdlog::logger> logger,
                           int thread_count,
                           int messages_per_thread) {
    Timer timer;
    
    std::vector<std::thread> threads;
    for (int t = 0; t < thread_count; ++t) {
        threads.emplace_back([logger, messages_per_thread, t]() {
            for (int i = 0; i < messages_per_thread; ++i) {
                logger->info("Thread {} - Message #{}", t, i);
            }
        });
    }
    
    for (auto& thread : threads) {
        thread.join();
    }
    
    // 刷新并等待完成
    logger->flush();
    
    // 给异步 logger 更多时间完成
    std::this_thread::sleep_for(std::chrono::milliseconds(200));
    
    double elapsed = timer.elapsed_ms();
    int total_messages = thread_count * messages_per_thread;
    double throughput = total_messages / (elapsed / 1000.0);
    
    std::cout << name << ":\n"
              << "  线程数: " << thread_count << "\n"
              << "  每线程消息数: " << messages_per_thread << "\n"
              << "  总消息数: " << total_messages << "\n"
              << "  耗时: " << elapsed << " ms\n"
              << "  吞吐量: " << static_cast<int>(throughput) << " msg/sec\n"
              << std::endl;
}

int main() {
    std::cout << "========================================" << std::endl;
    std::cout << "  MiniSpdlog 性能测试" << std::endl;
    std::cout << "========================================\n" << std::endl;
    
    // 确保 logs 目录存在
    create_directory("logs");
    
    constexpr int single_iterations = 100000;
    constexpr int multi_threads = 4;
    constexpr int multi_messages = 25000;
    
    try {
        // ========== 单线程性能对比 ==========
        std::cout << "【单线程性能测试 - " << single_iterations << " 条消息】\n" << std::endl;
        
        // 同步文件日志
        {
            std::cout << "测试同步文件日志..." << std::endl;
            minispdlog::drop("sync_file_bench");  // 清理可能存在的旧 logger
            
            auto sync_logger = minispdlog::basic_logger_mt(
                "sync_file_bench",
                "logs/bench_sync.log",
                true
            );
            benchmark_single_thread("同步文件日志", sync_logger, single_iterations);
            
            minispdlog::drop("sync_file_bench");
        }
        
        // 异步文件日志(block 策略)
        {
            std::cout << "测试异步文件日志(block策略)..." << std::endl;
            minispdlog::drop("async_file_bench");
            
            minispdlog::init_thread_pool(8192, 1);
            auto async_logger = minispdlog::async_file_mt(
                "async_file_bench",
                "logs/bench_async.log",
                true,
                minispdlog::async_overflow_policy::block
            );
            benchmark_single_thread("异步文件日志(block)", async_logger, single_iterations);
            
            minispdlog::drop("async_file_bench");
        }
        
        // 异步文件日志(overrun_oldest 策略)
        {
            std::cout << "测试异步文件日志(overrun策略)..." << std::endl;
            minispdlog::drop("async_file_bench_overrun");
            
            minispdlog::init_thread_pool(8192, 1);
            auto async_logger_overrun = minispdlog::async_file_mt(
                "async_file_bench_overrun",
                "logs/bench_async_overrun.log",
                true,
                minispdlog::async_overflow_policy::overrun_oldest
            );
            benchmark_single_thread("异步文件日志(overrun)", async_logger_overrun, single_iterations);
            
            minispdlog::drop("async_file_bench_overrun");
        }
        
        // ========== 多线程性能对比 ==========
        std::cout << "\n【多线程性能测试 - " << multi_threads << " 线程 x " 
                  << multi_messages << " 消息】\n" << std::endl;
        
        // 同步文件日志
        {
            std::cout << "测试同步文件日志(多线程)..." << std::endl;
            minispdlog::drop("sync_multi_bench");
            
            auto sync_logger = minispdlog::basic_logger_mt(
                "sync_multi_bench",
                "logs/bench_sync_multi.log",
                true
            );
            benchmark_multi_thread("同步文件日志", sync_logger, multi_threads, multi_messages);
            
            minispdlog::drop("sync_multi_bench");
        }
        
        // 异步文件日志(1个工作线程)
        {
            std::cout << "测试异步文件日志(1工作线程)..." << std::endl;
            minispdlog::drop("async_multi_bench");
            
            minispdlog::init_thread_pool(16384, 1);
            auto async_logger = minispdlog::async_file_mt(
                "async_multi_bench",
                "logs/bench_async_multi.log",
                true,
                minispdlog::async_overflow_policy::block
            );
            benchmark_multi_thread("异步文件日志(1工作线程)", async_logger, multi_threads, multi_messages);
            
            minispdlog::drop("async_multi_bench");
        }
        
        // 异步文件日志(2个工作线程)
        {
            std::cout << "测试异步文件日志(2工作线程)..." << std::endl;
            minispdlog::drop("async_multi_bench_2");
            
            minispdlog::init_thread_pool(16384, 2);
            auto async_logger_2 = minispdlog::async_file_mt(
                "async_multi_bench_2",
                "logs/bench_async_multi_2.log",
                true,
                minispdlog::async_overflow_policy::block
            );
            benchmark_multi_thread("异步文件日志(2工作线程)", async_logger_2, multi_threads, multi_messages);
            
            minispdlog::drop("async_multi_bench_2");
        }
        
        std::cout << "\n========================================" << std::endl;
        std::cout << "  性能测试完成!" << std::endl;
        std::cout << "========================================" << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "测试失败: " << e.what() << std::endl;
        return 1;
    }
    
    // 最后等待确保所有异步消息处理完成
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    
    return 0;
}
#endif


 #if 0
        // 异步文件日志(block 策略)
        {
            std::cout << "测试异步文件日志(block策略)..." << std::endl;
            minispdlog::drop("async_file_bench");
            
            //minispdlog::init_thread_pool(16384, 1);  // 更大的队列 
            minispdlog::init_thread_pool(32768, 1);
            auto async_logger = minispdlog::async_file_mt(
                "async_file_bench",
                "logs/bench_async.log",
                true,
                minispdlog::async_overflow_policy::block
            );
            benchmark_single_thread("异步文件日志(block)", async_logger, single_iterations, true);
            minispdlog::drop("async_file_bench");
        }
        
        // 异步文件日志(overrun_oldest 策略)
        {
            std::cout << "测试异步文件日志(overrun策略)..." << std::endl;
            minispdlog::drop("async_file_bench_overrun");
            
            minispdlog::init_thread_pool(16384, 1);
            auto async_logger_overrun = minispdlog::async_file_mt(
                "async_file_bench_overrun",
                "logs/bench_async_overrun.log",
                true,
                minispdlog::async_overflow_policy::overrun_oldest
            );
            benchmark_single_thread("异步文件日志(overrun)", async_logger_overrun, single_iterations, true);
            minispdlog::drop("async_file_bench_overrun");
        }
        #endif